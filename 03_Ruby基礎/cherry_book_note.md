エイリアスメソッド:同じメソッドに複数の名前がついてる   
(size length)

変数やメソッド、クラスなどにつける名前のことを識別子と呼ぶ。 
nilも偽   

?　真偽値を返す   
! 使用する際は注意が必要。呼び出したオブジェクトの状態を変更してしまうメソッド（破壊的メソッド）    
変数やメソッド名には! ?は使えない   

nil true false 擬似変数（代入しようとするとエラー）  

requireは1回しかライブラリやファイルを飲み込まない。  
自分で作成したプログラムがfalseになった場合は、loadを使用すると毎回無条件に指定したファイルを読み込みことができる(.rbは省略できない)    

---
puts : 戻り値 nil   
print : 戻り値 nil  一行で表示される  
※上2つは自動的にto_sメソッドを呼び出し文字列に変換    

p : 引数で渡されたオブジェクトそのものがメソッドの戻り値になる。ダブルクオートで表示される(デバックで使用)    
※Stringクラスのinspectメソッドによって値が出力される  

 
---
ruby for文ほぼ使わない    

```
nums.each do |sum_value|
  sum += sum_value
end

※ do end を抜かして{}
↓

nums.each {|sum_value| sum += sum_value}
```
map 結果を新しい配列に返す。    
find ブロックの戻り値が真になった最初の要素を返す。   

```
 p ['a','b','c'].map{|n| n.upcase}

 ↓
 
 p ['a','b','c'].map(&:upcase)
```
```
p [1, 2, 3, 4, 5].select{|n| n.odd?}

↓

p [1, 2, 3, 4, 5].select(&:odd?)
```
# &:

### ..(最後の値を含む)
### ...(最後の値を含まない)    

### splat展開 [*1...5]  
### rjust 右寄せ    

### hexメソッド　16進数の文字列を10進数の整数に変換   
('ff'.hex #=> 255)    

```　
-　差集合を求める演算子

a = [1, 2, 3]
b = [3, 4, 5]

p a - b

左の配列から右の配列に含まれる要素を取り除く。
```
```
&　２つの配列共通する要素を返す
a = [1, 2, 3]
b = [3, 4, 5]

p a & b　#=> 3
```
### | - & 元の配列は変更しない（非破壊的）

可変長引数 : 個数に制限のない引数   

### ハッシュはキーと値の組み合わせでデータを管理するオブジェクト。    
### シンボルは文字列に似ているが、中身は整数なので文字列よりも高速に処理ができる。メモリの使用効率が良くなる。

### ||=  変数がnilかfalseでなければ右辺のデータを代入する。

### ローカル変数は参照する前に必ず=で値を代入して作成する必要があります。   
### インスタンス変数はクラスの外部から参照が出来ない。参照したい場合は参照用のメソッドを作る必要があります。

---

### ローカル変数
参照する前に必ず=で値を代入して作成する必要がある

### インスタンス変数
クラスの外部から参照が出来ない。参照したい場合は参照用のメソッドを作る必要がある。    
変更したい場合も変更用のメソッドを定義する必要がある。    

﹂インスタンス変数の値を読み書きするメソッドのことを`アクセサメソッド`

## initialize: インスタンスを初期化するために実行したい処理があればinitializeメソッドで処理を実装する（privateメソッド）

### attr_reader 読み取り専用のメソッド = （ゲッターを定義しているのと同じ）
```
  @nameを外部から参照すためのメソッド

  def name
    @name
  end  

```

### attr_writer 書き込み専用のメソッド

##　インスタンス変数
クラスの外部から参照が出来ない。参照したい場合は参照用のメソッドを作る必要がある。    
変更したい場合も変更用のメソッドを定義する必要がある。
```
class User
  def initialize(name)
    #インスタンス変数
    @name = name
  end

  #インスタンスメソッド
  def hello
　　 #インスタンス変数に保存されている名前を表示
    "Hello, I am #{@name}"
  end
end

user = User.new('Alice')

p user.hello
```

##　ローカル変数
```
class User
  def initialize(name)
    @name = name 
  end

  def hello
    #ローカル変数は参照する前に必ず=で値を代入して作成する必要がある。
    shuffled_name = @name.chars.shuffle.join
    "Hello, I am #{shuffled_name}"
  end
end

user = User.new('Alice')
p user.hello
```

## セッター
```
  #セッターはインスタンス変数の値をセットするためのメソッド
  @nameを外部から変更するためのメソッド

  def name=(value)
    @name = value
  end
  
```

## ゲッター
```
  @nameを外部から参照すためのメソッド

  def name
    @name
  end  

```

やたらとinitializeメソッドが出る件。  
コンストラクタとも呼ばれる。jsのような  
(インスタンスを初期化する・共通の処理を行いたい時)    

#### クラスメソッドはインスタンス(new)化しない。

#### self
メソッドとインスタンス自身を表すselfキーワードがある。

#### メソッド内でセッターメソッドを呼び出す場合はselfを必ず付ける。

#### selfはオブジェクトそのものをさす。selfをメソッドで定義すると、オブジェクトではなく、そのクラスのオブジェクトになる。

#### privateメソッド: レシーバを指定して呼び出すことができないメソッド

#### eql? ハッシュのキーとして２つのオブジェクトが等しいかどうか判断

#### モンキーパッチ　既存の実装を上書きして、自分が期待する挙動に変更すること

#### 特異メソッド　特定のオブジェクトにだけ紐づくメソッド（数値・シンボルは特異メソッドを定義出来ない）

#### int と　sym は　イミュータブル

#### 動的型付け言語　実行時にそのメソッドが呼び出せるかどうかを判断し、呼び出せないときにはエラーが起きる。そのオブジェクトのクラス（データ型）が何かは見ていない。 メソッドが呼び出せるかどうか

#### ダックタイピング　オブジェクトのクラスが何であろうとそのメソッドが呼び出せれば良しとするプログラミングスタイル

#### モジュールをクラスにincludeして機能を追加することをミックスインと呼ぶ

#### 特異メソッド　= インスタンスメソッド
#### Enumerableモジュール　include先のクラスでeachメソッドが実装されていること

#### ObjectクラスがKernelモジュールをincludeしている。なのでputs p あたりがどこでも使えるようになっている。
　
#### トップレベル クラス構文やモジュール構文に囲まれていない一番外側の部分のこと

#### moduleの構文にトップクラスのclassを組み込む時は、
変数　= `::`クラス名.new を付ける。

